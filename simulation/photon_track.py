from chroma.sim import Simulation
from chroma.loader import load_bvh
from chroma.io.root import RootWriter
import numpy as np
import pandas as pd
import datetime
from source import photon_bomb, LED_ring, camera_source
import detector_construction


""" A copy of tests/adding.py, which changed:
Keep photons' tracks; a much smaller scale of simulation (~10)

Refer to chroma/gpu/photon.py/propagate() to view the details of data I/O.

Update: This script is used to run and plot the track of photons generated by light source.
The data I/O was outdated - using pandas, for example.
You may make use of it to test your own light source.
"""


def simulate():
    g = detector_construction.test_geometry()
    g.flatten()
    g.bvh = load_bvh(g)
    sim = Simulation(g, photon_tracking=True)

    #namestr = 'mode'+str(mode)
    #namestr = namestr + '_track.root'
    namestr = 'track.root'
    length_of_batch = 100

    # write it to a root file
    f = RootWriter(namestr)

    for ev in sim.simulate([photon_bomb(length_of_batch,400,(0,0,0))],
                           keep_photons_beg=True,keep_photons_end=True,
                           run_daq=False,max_steps=20):
        f.write_event(ev)
    
    f.close()

if __name__ == '__main__':

    ti = pd.to_datetime(datetime.datetime.now())

    g = detector_construction.detector_reflector()
    g.flatten()
    g.bvh = load_bvh(g)
    sim = Simulation(g, photon_tracking=True)

    dx, dy, dz = 0.03910, 0.06772, 0.34958
    pos_measure = np.array([0, np.sqrt(dx*dx+dy*dy), dz])
    l_deviation = 0.0005
    pos_center = pos_measure - np.array([0,l_deviation*np.sin(22.5*np.pi/180),l_deviation*np.cos(22.5*np.pi/180)])
    dir_center = np.array([0, -1*np.sin(22.5*np.pi/180), -1*np.cos(22.5*np.pi/180)])

    length_of_batch = 50
    res = sim.simulate([photon_bomb(length_of_batch,850,(0,0,0.2))],keep_photons_beg=True,keep_photons_end=True,run_daq=True,max_steps=20)

    pos_photon = []
    for ev in res:
        track = list(ev.photon_tracks)
        for ph in track:
            pos_photon.append(ph.pos) # write the position in units of photon
    np.save('res.npy', np.array(pos_photon))
    
    # Then run LED source
    led = sim.simulate([LED_ring(850, length_of_batch, pos_center, dir_center)],
                           keep_photons_beg=True,keep_photons_end=True,
                           run_daq=True,max_steps=20)
    pos_photon = []
    for ev in led:
        track = list(ev.photon_tracks)
        for ph in track:
            pos_photon.append(ph.pos) # write the position in units of photon
    np.save('led.npy', np.array(pos_photon))

    # test cam source
    h_cone = 0.060325
    pos_sapphire = pos_measure + np.array([0,h_cone*np.sin(22.5*np.pi/180),h_cone*np.cos(22.5*np.pi/180)])
    dir_sapphire = np.array([0, -1*np.sin(22.5*np.pi/180), -1*np.cos(22.5*np.pi/180)])
    cam = sim.simulate([camera_source(850, length_of_batch, pos_sapphire, dir_sapphire)],
                           keep_photons_beg=True,keep_photons_end=True,
                           run_daq=True,max_steps=20)
    pos_photon = []
    for ev in cam:
        track = list(ev.photon_tracks)
        for ph in track:
            pos_photon.append(ph.pos) # write the position in units of photon
    np.save('cam.npy', np.array(pos_photon))

    tf = datetime.datetime.now()
    dt = tf - ti
    print("The total time cost: ")
    print(dt)